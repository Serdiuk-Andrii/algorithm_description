\documentclass[14pt]{extarticle} 
\usepackage[english]{babel}
\usepackage[lighttt]{lmodern}
\usepackage{amsmath}

\usepackage{xcolor}
\usepackage{listings}

% Package for urls
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
	pdftitle={Overleaf Example},
	pdfpagemode=FullScreen,
}

\DeclareMathOperator{\desc}{desc}

\lstset{
	language=Python,
	basicstyle=\small,
	otherkeywords={self},             
	keywordstyle=\ttfamily\color{blue!90!black},
	keywords=[2]{True,False},
	keywords=[3]{ttk},
	keywordstyle={[2]\ttfamily\color{yellow!80!orange}},
	keywordstyle={[3]\ttfamily\color{red!80!orange}},
	emph={MyClass,__init__},          
	emphstyle=\ttfamily\color{red!80!black},    
	stringstyle=\color{green!80!black},
	showstringspaces=false            
}

\newtheorem{definition}{Definition}

\newtheorem{lemma}{Lemma}
\newcommand{\sgcomment}[1]{\textcolor{blue}{SG: #1}}


\begin{document}
	
	
\title{"Path aware" alignment}
\date{}

\section{Problem description}

There are two main graphical objects in computational genetics --- the pedigree and the coalescence tree. The pedigree (also called genealogical tree or family tree) describes the relations between parents and their children. The coalescence tree, on the other hand, describes how alleles within the pedigree may have originated from the common ancestor. The coalescence tree can and should be thought of as the topology of a pedigree, which represents only the information that we are interested in. Notice that a coalescence tree is a directed graph, but it can still have loops if we release the orientation. In other words, a coalescence tree is not an orientation of a tree, but it is a DAG (directed acyclic graph).

In order to be able to take recombination events into account, we need to use a more complicated structure called ARG (ancestral recombination graph) which gives a more realistic understanding of how the genetic material is transmitted. Generally speaking, an ARG is a sequence of highly correlated coalescence trees that describe the allele transmissions within the same pedigree but across different positions along the genome.  More information about ARG can be found \href{https://nielsen-lab.github.io/pdfs/papers/argeval.pdf}{here}. 

In most cases, various statistical methods are used in order to derive the ARG from the pedigree. One of the most well-known libraries used for deriving the ARG are: \href{https://palamaralab.github.io/software/argneedle/}{ARG-Needle}, \href{https://palamaralab.github.io/software/asmc/}{ASMC}, \href{https://myersgroup.github.io/relate/}{Relate} and \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6726478/}{tsinfer}. Some of these methods are more accurate and require a lot of resources, while the others are scalable but are not accurate enough.

Unfortunately, there are multiple types of errors in the data that we have to account for in order to find the correct solution for the problem. Firstly, we should remember that ARG can have errors because it is obtained by using statistical methods. Apart from that, errors can also happen in the pedigree for various reasons (adopted children, errors in documents, etc.).  

\section{Problem statement}

\subsection{Notation}

Given a pedigree, represented as a directed acyclic graph $P = \{H, F\},$ where $H$ represents haploid individuals or ploids (vertices in the graph) and $F$ are genealogical filiations (edges in the graph), and a gene (coalescent) tree $C = \{V(C), E(C)\}.$ Our goal is to `align' the tree and the graph, i.e., find the path taken by the gene tree in the pedigree. Our solution can be encoded as a map from edges of $C$ to vertices of $P$:

We do this in two steps, first by assigning sex to individuals along edges of the coalescent tree, then using genealogical sex assignments to map edges to genealogical individuals.  

\begin{definition}
An edge path map $M_e:E(C) \rightarrow {0,1}*$ is a map from edges of the coalescent tree to a binary string representing whether alleles along the edge were maternally ($0$) or paternally ($1$) inherited.     
\end{definition}

Similarly, 
\begin{definition}
A ploid path map of length $k$ is a map $M_k:S \rightarrow {0,1}*k$ from a set of genealogical ploids $S$ to binary strings of length $k$ representing the path of ancestral transmissions of this allele, according to whether they were maternally ($0$) or paternally ($1$) inherited.      
\end{definition}

Such sex path maps describe past biological events. Given a genealogy, a sex path implies a genealogical path. However, if a genealogy contains error, the implied genealogical path may be incorrect. 

\begin{definition}
An error path map of length $k$ is a map $M_k:S \rightarrow {0,1}*k$ from a set of genealogical ploids $S$ to binary strings of length $k$ representing the path of ancestral transmissions of this allele, according to whether they were maternally ($0$) or paternally ($1$) inherited.      
\end{definition}


\begin{definition}
An edge map $M_e:E(C) \rightarrow P(H)$ is a map from the edges of the coalescent tree to a binary string directed paths in the genealogy.    
\end{definition}

edge maps are used to record the entire inheritance path in the genealogy corresponding to a coalescent tree. Some edges in the gene genealogies will be above the founders of the genealogy. We can imagine that the genealogy is supplemented with an an ancestral node $a$ from which all genealogical founders descend.  



\subsection{Statement of the problem} 

Let us say that the coalescent tree $C$ was generated by coalescent simulation from pedigree $P$. In this case, the correct map $M_e$ is defined by the simulation process. 
In our problem we are provided with a partial map: 

\begin{definition}
A partial edge map $M_p:E(C) \rightarrow P(H) \cup \{u\}$ is a map from the edges of the coalescent tree to either a directed path in the genealogy, or an unassigned state $u$.    
\end{definition}



Our task, given a partial edge map $M_p$, is to reconstruct an $M_e$ and $M_e$ given $L$ and the laws of mendelian inheritance.  
\begin{definition}
	Let $D$ be a directed graph and $a_1, a_2 \in V(D)$. A vertex $v \in V(D)$ is said to a most recent common ancestor (MRCA) of $a_1$ and $a_2$ if there exists 
	a directed path $P_{v,a_1}$ between $v$ and $a_1$ and a directed path $P_{v,a_2}$ between $v$ and $a_2$ such that $P_{v,a_1} \cap P_{v,a_2} = \{v\}.$	
\end{definition}

We can define MRCA for pedigrees ($PMRCA$) and for coalescent trees ($CMRCA$).


\begin{lemma}
If a vertex map $M_v$ respects mendelian inheritance, and if coalescent node $u$ is an $CMRCA$ to coalescent nodes $v, w$, then $M_v(u) \in PMRCA(M(v),M(w))$   
\end{lemma}



 

\subsection{Formulation 1: Vertex only} 

\subsection{Formulation 2: Vertex-only with path-specific output}

\textbf{Consistency condition:} 

\section{Preprocessing stage}

The preprocessing stage consists of three steps:

\subsection{Reading the pedigree}

During this step, we simply read the pedigree from a file and save the information about the graph. The time complexity of this step is $O(n)$ where $n$ is the number of vertices in the graph.

\subsection{Calculating the levels and descendants lists from the probands}

Next, we calculate the levels of the graph and the descendant list for every vertex in the graph. Every vertex has to know its descendants because we need this information to discard graphical common ancestors that are not genealogical common ancestors later in the algorithm.

Generally speaking, having descendants for every vertex can require a lot of memory. According to my calculations, we should still be able to store it for large graphs. There are different more complicated approaches that can take a little bit more time but save a lot of memory. Since the preprocessing step is done only once, we can afford to spend more time during this step to lower the memory requirements.

In the "path aware" approach, the descendant list also stores the path to every descendant.



\begin{definition}
A vertex map $M_v:V(C) \rightarrow H$ is a map from the coalescent vertices to the pedigree vertices.   
\end{definition}
vertex maps are used to identify genealogical individuals in which coalescences have occurred. 

\subsection{Preprocessing the common ancestors map}

Starting with the founders (whose map entries has been already calculated), the algorithm fills the common ancestors map for all the other vertices going level by level.

\subsection{Result}

In the end, we have a three-dimensional matrix (a dictionary of dictionaries of dictionaries) that returns a common ancestry object for a triple $(a, b, c)$ where $c$ is a common ancestor of $a$ and $b$.

The common ancestry object contains all the paths by which $a$ and $b$ can reach $c$.

\begin{lstlisting}

class PathCommonAncestry:
	
	def __init__(self, common_ancestor: int,
		first_vertex: int, second_vertex: int,
		first_vertex_paths: [Path],
		second_vertex_paths: [Path]):
		self.common_ancestor = common_ancestor
		self.first_vertex = first_vertex
		self.second_vertex = second_vertex
		self.first_vertex_paths = first_vertex_paths
		self.second_vertex_paths = second_vertex_paths
	

\end{lstlisting}

\newpage

\section{Alignment}

\vspace*{-\baselineskip}

\begin{lstlisting}

class PathAligner:

def align():
# Get current partial mapping
partial_mapping = get_partial_mapping()
iterator = get_vertex_iterator()
while not iterator.finished():
	# Vertex in the coalescence tree that has not been mapped
	vertex_to_map = iterator.next()
	# Get the candidates for the vertex. If vertex_to_map has only
	# one child (no coalescence), return None
	candidates = get_candidates_for_vertex(vertex_to_map)
	if candidates is None:
		partial_mapping[vertex_to_map] = None
		continue
	result = []
	for candidate in candidates:
		if verify_assignment(vertex_to_map, candidate):
			result.append(candidate)
	# If there are no candidates whose assignment are consistent,
	# trace back to the previous decision
	if not result:
		return None			
	while length(result) > 0:
		candidate_to_try = result.pop()
		aligner = PathAligner(self)
		alignment_result = aligner.align()
		if alignment_result is not None:
			return alignment_result
	# None of the assignment worked, return None
	return None
\end{lstlisting}


\end{document}