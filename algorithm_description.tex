\documentclass[14pt]{extarticle} 
\usepackage[english]{babel}
\usepackage[lighttt]{lmodern}
\usepackage{amsmath}

\usepackage{xcolor}
\usepackage{listings}

\DeclareMathOperator{\desc}{desc}

\lstset{
	language=Python,
	basicstyle=\small,
	otherkeywords={self},             
	keywordstyle=\ttfamily\color{blue!90!black},
	keywords=[2]{True,False},
	keywords=[3]{ttk},
	keywordstyle={[2]\ttfamily\color{yellow!80!orange}},
	keywordstyle={[3]\ttfamily\color{red!80!orange}},
	emph={MyClass,__init__},          
	emphstyle=\ttfamily\color{red!80!black},    
	stringstyle=\color{green!80!black},
	showstringspaces=false            
}

\newtheorem{definition}{Definition}

\newtheorem{lemma}{Lemma}
\newcommand{\sgcomment}[1]{\textcolor{blue}{SG: #1}}


\begin{document}
	
	
\title{"Path aware" alignment}
\date{}


\section{Problem statement}

\subsection{Notation}

Given a pedigree, represented as a directed acyclic graph $P = \{H, F\},$ where $H$ represents haploid individuals or ploids (vertices in the graph) and $F$ are genealogical filiations (edges in the graph), and a gene (coalescent) tree $C = \{V(C), E(C)\}.$ Our goal is to `align' the tree and the graph, i.e., find the path taken by the gene tree in the pedigree. Our solution can have two different levels of resolution


\begin{definition}
A vertex map $M_v:V(C) \rightarrow H$ is a map from the coalescent vertices to the pedigree vertices.   
\end{definition}
vertex maps are used to identify genealogical individuals in which coalescences have occurred. 

\begin{definition}
An edge map $M_e:E(C) \rightarrow P(H)$ is a map from the edges of the coalescent tree to directed paths in the genealogy.    
\end{definition}
edge maps are used to record the entire inheritance path in the genealogy corresponding to a coalescent tree.  



\subsection{Statement of the problem} 

Let us say that the coalescent tree $C$ was generated by coalescent simulation from pedigree $G$. In this case, the correct maps $M_v$ and $M_e$ are defined by the simulation process. To mimic real data, imagine that we are only  given a map for the leaves of $C$: $L: \operatorname{leaves}{C} \rightarrow H.$ Our task is to reconstruct $M_v$ and $M_e$ given $L$ and the laws of mendelian inheritance.  

\begin{definition} (Correct)
	Let $D$ be a directed graph and $a_1, a_2 \in V(D)$. A vertex $v \in V(D)$ is said to a most recent genealogical common ancestor of $a_1$ and $a_2$ if there exists 
	a directed path $P_{v,a_1}$ between $v$ and $a_1$ and a directed path $P_{v,a_2}$ between $v$ and $a_2$ such that $P_{v,a_1} \cap P_{v,a_2} = \{v\}.$	
\end{definition}



\begin{lemma}
If a vertex map $M_v$ respects mendelian inheritance, and if coalescent node $u$ is parent to coalescent nodes $v, w$, then $M_v(u) \in MRGCA(v,w)$   
\end{lemma}



 

\subsection{Formulation 1: Vertex only} 

\begin{definition} (Equivalent)
	
	Let $D$ be a directed graph, $A = \{a_1,  a_2\}$ be a set of two vertices in $V(D)$, and $v \in V(D)$. Put $C = \{u \in V(D) | A \subset \desc(u) \}$. The vertex $v \in V(D)$ is said to a genealogical common ancestor of $A$ if:
	
	\begin{itemize}
		\item 
		$v \in C,$
		\item 
		$A \subset \desc_{D'}(v)$ where $D' = D -  (C \setminus \{v\}).$
	\end{itemize}
	
\end{definition}



\textbf{Consistency condition:}  $\forall v \in V(C)$ with $|N^{+}_C(u)| > 1$ it holds that $\forall c_1, c_2 \in N^{+}_C(u), c_1 \ne c_2$ $M(v)$ is a genealogical common ancestor of $M(c_1)$ and $M(c_2)$.


\subsection{Formulation 2: Vertex-only with path-specific output}

\section{Preprocessing stage}

The preprocessing stage consists of three steps:

\subsection{Reading the pedigree}

During this step, we simply read the pedigree from a file and save the information about the graph. The time complexity of this step is $O(n)$ where $n$ is the number of vertices in the graph.

\subsection{Calculating the levels and descendants lists from the probands}

Next, we calculate the levels of the graph and the descendant list for every vertex in the graph. Every vertex has to know its descendants because we need this information to discard graphical common ancestors that are not genealogical common ancestors later in the algorithm.

Generally speaking, having descendants for every vertex can require a lot of memory. According to my calculations, we should still be able to store it for large graphs. There are different more complicated approaches that can take a little bit more time but save a lot of memory. Since the preprocessing step is done only once, we can afford to spend more time during this step to lower the memory requirements.

In the "path aware" approach, the descendant list also stores the path to every descendant.

\subsection{Preprocessing the common ancestors map}

Starting with the founders (whose map entries has been already calculated), the algorithm fills the common ancestors map for all the other vertices going level by level.

\subsection{Result}

In the end, we have a three-dimensional matrix (a dictionary of dictionaries of dictionaries) that returns a common ancestry object for a triple $(a, b, c)$ where $c$ is a common ancestor of $a$ and $b$.

The common ancestry object contains all the paths by which $a$ and $b$ can reach $c$.

\begin{lstlisting}

class PathCommonAncestry:
	
	def __init__(self, common_ancestor: int,
		first_vertex: int, second_vertex: int,
		first_vertex_paths: [Path],
		second_vertex_paths: [Path]):
		self.common_ancestor = common_ancestor
		self.first_vertex = first_vertex
		self.second_vertex = second_vertex
		self.first_vertex_paths = first_vertex_paths
		self.second_vertex_paths = second_vertex_paths
	

\end{lstlisting}

\newpage

\section{Alignment}

\vspace*{-\baselineskip}

\begin{lstlisting}

class PathAligner:

def align():
# Get current partial mapping
partial_mapping = get_partial_mapping()
iterator = get_vertex_iterator()
while not iterator.finished():
	# Vertex in the coalescence tree that has not been mapped
	vertex_to_map = iterator.next()
	# Get the candidates for the vertex. If vertex_to_map has only
	# one child (no coalescence), return None
	candidates = get_candidates_for_vertex(vertex_to_map)
	if candidates is None:
		partial_mapping[vertex_to_map] = None
		continue
	result = []
	for candidate in candidates:
		if verify_assignment(vertex_to_map, candidate):
			result.append(candidate)
	# If there are no candidates whose assignment are consistent,
	# trace back to the previous decision
	if not result:
		return None			
	while length(result) > 0:
		candidate_to_try = result.pop()
		aligner = PathAligner(self)
		alignment_result = aligner.align()
		if alignment_result is not None:
			return alignment_result
	# None of the assignment worked, return None
	return None
\end{lstlisting}


\end{document}